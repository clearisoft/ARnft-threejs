{"version":3,"file":"ARnftThreejs.js","sources":["../src/NFTRootTJS.ts","../src/markermedia/NFTImageTJS.ts"],"sourcesContent":["import { Euler, Object3D, Matrix4, Quaternion, Vector3 } from 'three';\nimport { IMediaNode } from \"./media-node/IMediaNode\";\n\nexport abstract class NFTNodeTJS implements IMediaNode  {\n\n    protected world: any;\n\n    protected translation: any;\n    protected rotation: any;\n    protected scale: any;\n\n    private _hasFound: boolean = false;\n\n    private _interpolationFactor: number = 15;\n\n    private _lastTranslation: Vector3;\n\n    private _frameDrops: number = 0;\n\n    private _root: Object3D;\n\n    private _deltaAccuracy: number = 10;\n\n    /*public get root(): Object3D {\n        return this._root;\n    }\n\n    public set root(value: Object3D) {} {\n        this._root = new value;\n    }*/\n\n    public get deltaAccuracy(): number {\n        return this._deltaAccuracy;\n    }\n\n    public set deltaAccuracy(value: number) {\n        this._deltaAccuracy = value;\n    }\n\n    public get interpolationFactor(): number {\n        return this._interpolationFactor;\n    }\n\n    public set interpolationFactor(value: number) {\n        this._interpolationFactor = value;\n    }\n\n    private trackedMatrix: any = {\n        // for interpolation\n        delta: [\n            0, 0, 0, 0,\n            0, 0, 0, 0,\n            0, 0, 0, 0,\n            0, 0, 0, 0\n        ],\n        interpolated: [\n            0, 0, 0, 0,\n            0, 0, 0, 0,\n            0, 0, 0, 0,\n            0, 0, 0, 0\n        ]\n    }\n\n    public found(world:any){\n        this.world = world;\n    }\n\n    public update(): void {\n        if (!this.world) {\n            this._hasFound = false;\n            this._frameDrops = 0;\n\n            this._root.visible = false;\n        } else {\n            let worldMatrix: Matrix4 = new Matrix4().fromArray(this.getArrayMatrix(this.world));\n            worldMatrix.decompose(this.translation, this.rotation, this.scale)\n            //let worldMatrix: Matrix = Matrix.FromArray(this.getArrayMatrix(this.world));\n\n            if (!this._hasFound) {\n                this._root.visible = true;\n                for (var i = 0; i < 16; i++) {\n                    this.trackedMatrix.interpolated[i] = this.world[i];\n                }\n                this._hasFound = true;\n                this._lastTranslation = new Vector3().setFromMatrixPosition(worldMatrix);\n            }\n            else {\n                //let _currentTranslation: Vector3 = worldMatrix.getTranslation();\n                let _currentTranslation: Vector3 = new Vector3().setFromMatrixPosition(worldMatrix);\n\n                //if (Math.abs(Vector3.Distance(_currentTranslation, this._lastTranslation)) > this._deltaAccuracy) {\n                if (Math.abs(_currentTranslation.distanceTo(this._lastTranslation)) > this._deltaAccuracy) {\n                    this._frameDrops += 1;\n                    if (this._frameDrops > 3) {\n                        this._lastTranslation = _currentTranslation;\n                    }\n                    return;\n                }\n                this._frameDrops = 0;\n                this._lastTranslation = _currentTranslation;\n                for (var i = 0; i < 16; i++) {\n                    this.trackedMatrix.delta[i] = this.world[i] - this.trackedMatrix.interpolated[i];\n                    this.trackedMatrix.interpolated[i] = this.trackedMatrix.interpolated[i] + (this.trackedMatrix.delta[i] / this._interpolationFactor);\n                }\n            }\n            let matrix: Matrix4 = new Matrix4().fromArray(this.getArrayMatrix(this.trackedMatrix.interpolated));\n\n            let rotMatrix: Matrix4 = new Matrix4()\n            rotMatrix.extractRotation(matrix);\n            let rotationQ: Quaternion = new Quaternion().setFromRotationMatrix(rotMatrix);\n            let EulerFromQ = new Euler().setFromQuaternion(rotationQ)//toEulerAngles\n            this._root.setRotationFromEuler(EulerFromQ)// = new Euler().setFromQuaternion(rotation)//toEulerAngles(\n\n            //let pos = Vector3.TransformCoordinates(new Vector3(0, 0, 0), matrix);\n            //this._root.setAbsolutePosition(pos);\n            this._root.position.set(this.translation.x, this.translation.y, this.translation.z);// = this.translation;\n        }\n    }\n\n    protected getArrayMatrix(value: any): any {\n        var array: any = [];\n        for (var key in value) {\n            array[key] = value[key]; //.toFixed(4);\n        }\n        return array;\n    }\n\n    static setMatrix (matrix: any, value: any) {\n      const array: any = []\n      for (const key in value) {\n        array[key] = value[key]\n      }\n      if (typeof matrix.elements.set === 'function') {\n        matrix.elements.set(array)\n      } else {\n        matrix.elements = [].slice.call(array)\n      }\n    };\n}\n","import { NFTNodeTJS } from \"../NFTRootTJS\";\nimport { Object3D, TextureLoader, PlaneGeometry, Mesh, MeshStandardMaterial } from 'three'\n\nexport class NFTImageTJS extends NFTNodeTJS {\n    private imageRoot: Object3D;\n    constructor(root: Object3D) {\n        super()\n        this.imageRoot = root;\n    }\n\n    public addNFTImage(imageUrl: string, width: number, height: number) {\n        const geometry = new PlaneGeometry( width, height, 30 );\n        const texture = new TextureLoader().load( imageUrl );\n        const material = new MeshStandardMaterial({map: texture});\n        const plane = new Mesh( geometry, material );\n        this.imageRoot.add(plane);\n    }\n}\n"],"names":["THREE"],"mappings":"otBA0E2CA,+IAcYA,+kBAJXA,mDAqBNA,qFAEGA,8CAEGA,kDACXA,48DCnGJA,mCACDA,mCACCA,0CACHA"}